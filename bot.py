import os
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, CallbackQueryHandler, ContextTypes
from telegram.constants import ParseMode
from aiohttp import web
import asyncio

from config import BOT_TOKEN
from utils.ytsearch import search_youtube_multiple, save_user_search
from utils.downloader import download_audio, cleanup_old_files
from utils.lyrics import get_lyrics
from utils.recommender import store_artist, get_recommendations
import time

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ü—Ä–æ—Å—Ç–æ–π –∫—ç—à –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞
search_cache = {}
CACHE_TIMEOUT = 300  # 5 –º–∏–Ω—É—Ç

def get_cached_search(query, count=6):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏–∑ –∫—ç—à–∞ –∏–ª–∏ –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫"""
    cache_key = f"{query}_{count}"
    current_time = time.time()
    
    if cache_key in search_cache:
        cached_data, timestamp = search_cache[cache_key]
        if current_time - timestamp < CACHE_TIMEOUT:
            return cached_data
    
    # –ù–æ–≤—ã–π –ø–æ–∏—Å–∫
    results = search_youtube_multiple(query, count)
    search_cache[cache_key] = (results, current_time)
    
    # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –∫—ç—à
    if len(search_cache) > 50:
        oldest_key = min(search_cache.keys(), key=lambda k: search_cache[k][1])
        del search_cache[oldest_key]
    
    return results

# –•—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
user_search_results = {}
user_modes = {}

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫"""
    logger.error(f"Exception while handling an update: {context.error}")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–°—Ç–∞—Ä—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"""
    welcome_text = """
üéµ <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Music Search Bot!</b> üéµ

üî• <i>–¢–≤–æ–π –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç</i>

<b>‚ú® –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:</b>
üéØ –ü–æ–∏—Å–∫ —Å –≤—ã–±–æ—Ä–æ–º –∏–∑ 5+ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
üé≠ –ü–æ–∏—Å–∫ –ø–æ –∞—Ä—Ç–∏—Å—Ç—É
üìú –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–≤ –ø–µ—Å–µ–Ω
üé™ –£–º–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
üì• –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤ MP3

<b>‚ö†Ô∏è –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:</b>
–ò–∑-–∑–∞ ÔøΩÔøΩ–µ–≥–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≤–∏–¥–µ–æ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.
–ë–æ—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã –ø–æ–∏—Å–∫–∞.

<b>–ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏ –∏–ª–∏ –∞—Ä—Ç–∏—Å—Ç–∞!</b>
    """
    
    keyboard = [
        [
            InlineKeyboardButton("üîç –ü–æ–∏—Å–∫ –ø–µ—Å–Ω–∏", callback_data="search_song"),
            InlineKeyboardButton("üé≠ –ü–æ–∏—Å–∫ –ø–æ –∞—Ä—Ç–∏—Å—Ç—É", callback_data="search_artist")
        ],
        [
            InlineKeyboardButton("üìú –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç", callback_data="get_lyrics"),
            InlineKeyboardButton("üéµ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏", callback_data="recommend")
        ]
    ]
    
    await update.message.reply_text(
        welcome_text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode=ParseMode.HTML
    )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    
    if query.data == "search_song":
        user_modes[user_id] = "search_song"
        await query.message.reply_text(
            "üîç <b>–†–µ–∂–∏–º –ø–æ–∏—Å–∫–∞ –ø–µ—Å–µ–Ω –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!</b>\n\n"
            "–ù–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏, –∏ —è –Ω–∞–π–¥—É –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è –≤—ã–±–æ—Ä–∞ üéµ\n\n"
            "<i>üí° –°–æ–≤–µ—Ç: –ü–æ–ø—Ä–æ–±—É–π –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –ø–µ—Å–Ω–∏ –¥–ª—è –ª—É—á—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</i>",
            parse_mode=ParseMode.HTML
        )
    
    elif query.data == "search_artist":
        user_modes[user_id] = "search_artist"
        await query.message.reply_text(
            "üé≠ <b>–ü–æ–∏—Å–∫ –ø–æ –∞—Ä—Ç–∏—Å—Ç—É –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!</b>\n\n"
            "–ù–∞–ø–∏—à–∏ –∏–º—è –∞—Ä—Ç–∏—Å—Ç–∞, –∏ —è –Ω–∞–π–¥—É –µ–≥–æ –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –ø–µ—Å–Ω–∏ üåü",
            parse_mode=ParseMode.HTML
        )
    
    elif query.data == "get_lyrics":
        user_modes[user_id] = "lyrics"
        await query.message.reply_text(
            "üìú <b>–†–µ–∂–∏–º –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–æ–≤ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!</b>\n\n"
            "–ù–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ üé§\n\n"
            "<i>‚ö†Ô∏è –°–µ—Ä–≤–∏—Å —Ç–µ–∫—Å—Ç–æ–≤ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω</i>",
            parse_mode=ParseMode.HTML
        )
    
    elif query.data == "recommend":
        await show_recommendations(query.message, user_id)
    
    elif query.data.startswith("download_"):
        await handle_download(query, user_id)
    
    elif query.data.startswith("lyrics_"):
        await handle_lyrics_from_search(query, user_id)

async def show_recommendations(message, user_id):
    """–ü–æ–∫–∞–∑ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π"""
    recs = get_recommendations(user_id)
    
    if not recs:
        keyboard = [[InlineKeyboardButton("üîç –ù–∞—á–∞—Ç—å –ø–æ–∏—Å–∫", callback_data="search_song")]]
        await message.reply_text(
            "ü§î <b>–ü–æ–∫–∞ –Ω–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π!</b>\n\n"
            "–°–Ω–∞—á–∞–ª–∞ –Ω–∞–π–¥–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–µ—Å–µ–Ω, —á—Ç–æ–±—ã —è –º–æ–≥ –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å —á—Ç–æ-—Ç–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–µ! üéµ",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode=ParseMode.HTML
        )
        return
    
    user_search_results[user_id] = recs
    
    text = "üéØ <b>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è —Ç–µ–±—è:</b>\n\n"
    keyboard = []
    
    for i, rec in enumerate(recs[:6]):
        source_emoji = "üéµ" if rec.get('source') == 'demo' else "üé∂"
        text += f"{source_emoji} <b>{i+1}.</b> {rec['title']}\n"
        text += f"üë§ {rec['uploader']}\n\n"
        
        keyboard.append([
            InlineKeyboardButton(f"üì• #{i+1}", callback_data=f"download_{i}"),
            InlineKeyboardButton(f"üìú #{i+1}", callback_data=f"lyrics_{i}")
        ])
    
    keyboard.append([InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="recommend")])
    
    await message.reply_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode=ParseMode.HTML
    )

async def text_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    text = update.message.text
    mode = user_modes.get(user_id, "search_song")

    if mode == "lyrics":
        await handle_lyrics_search(update.message, text)
    elif mode == "search_artist":
        await handle_artist_search(update.message, text, user_id)
    else:
        await handle_song_search(update.message, text, user_id)

async def handle_song_search(message, query, user_id):
    """–ü–æ–∏—Å–∫ –ø–µ—Å–µ–Ω"""
    loading_msg = await message.reply_text(
        "üîç <b>–ò—â—É –ø–µ—Å–Ω–∏...</b> ‚ö°\n\n"
        "<i>–ü—Ä–æ–±—É—é —Ä–∞–∑–Ω—ã–µ –º–µ—Ç–æ–¥—ã –ø–æ–∏—Å–∫–∞...</i>",
        parse_mode=ParseMode.HTML
    )
    
    try:
        results = get_cached_search(query, 6)
        await loading_msg.delete()
        
        if not results:
            await message.reply_text(
                f"‚ùå <b>–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ:</b> <i>{query}</i>\n\n"
                "üí° –ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n"
                "‚Ä¢ –ë–æ–ª–µ–µ –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –ø–µ—Å–Ω–∏\n"
                "‚Ä¢ –î—Ä—É–≥–æ–µ –Ω–∞–ø–∏—Å–∞–Ω–∏–µ\n"
                "‚Ä¢ –ò–º—è –∞—Ä—Ç–∏—Å—Ç–∞ + –Ω–∞–∑–≤–∞–Ω–∏–µ",
                parse_mode=ParseMode.HTML
            )
            return
        
        user_search_results[user_id] = results
        
        text = f"üéµ <b>–ù–∞–π–¥–µ–Ω–æ {len(results)} –ø–µ—Å–µ–Ω:</b> <i>{query}</i>\n\n"
        keyboard = []
        
        for i, result in enumerate(results):
            source_emoji = "üéµ" if result.get('source') == 'demo' else "üé∂"
            text += f"{source_emoji} <b>{i+1}.</b> {result['title']}\n"
            text += f"üë§ {result['uploader']}\n"
            
            if result.get('source'):
                source_name = {
                    'youtube_direct': 'YouTube',
                    'youtube_proxy': 'YouTube (Proxy)',
                    'invidious': 'Invidious',
                    'demo': 'Demo'
                }.get(result['source'], result['source'])
                text += f"üì° {source_name}\n"
            
            text += "\n"
            
            keyboard.append([
                InlineKeyboardButton(f"üì• #{i+1}", callback_data=f"download_{i}"),
                InlineKeyboardButton(f"üìú #{i+1}", callback_data=f"lyrics_{i}")
            ])
        
        keyboard.append([InlineKeyboardButton("üéØ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏", callback_data="recommend")])
        
        await message.reply_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        await loading_msg.delete()
        await message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {str(e)}")

async def handle_artist_search(message, artist_name, user_id):
    """–ü–æ–∏—Å–∫ –ø–æ –∞—Ä—Ç–∏—Å—Ç—É"""
    loading_msg = await message.reply_text(
        f"üé≠ <b>–ò—â—É –ø–µ—Å–Ω–∏ –∞—Ä—Ç–∏—Å—Ç–∞...</b> ‚ö°\n\n"
        "<i>–ò—Å–ø–æ–ª—å–∑—É—é –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –º–µ—Ç–æ–¥—ã...</i>",
        parse_mode=ParseMode.HTML
    )
    
    try:
        store_artist(user_id, artist_name)
        results = get_cached_search(f"{artist_name} songs", 6)
        await loading_msg.delete()
        
        if not results:
            await message.reply_text(
                f"‚ùå <b>–ê—Ä—Ç–∏—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω:</b> <i>{artist_name}</i>\n\n"
                "üí° –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –±–æ–ª–µ–µ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –∞—Ä—Ç–∏—Å—Ç–æ–≤",
                parse_mode=ParseMode.HTML
            )
            return
        
        user_search_results[user_id] = results
        
        text = f"üé≠ <b>–ü–µ—Å–Ω–∏ –∞—Ä—Ç–∏—Å—Ç–∞:</b> <i>{artist_name}</i>\n\n"
        keyboard = []
        
        for i, result in enumerate(results):
            source_emoji = "üéµ" if result.get('source') == 'demo' else "üé∂"
            text += f"{source_emoji} <b>{i+1}.</b> {result['title']}\n\n"
            
            keyboard.append([
                InlineKeyboardButton(f"üì• #{i+1}", callback_data=f"download_{i}"),
                InlineKeyboardButton(f"üìú #{i+1}", callback_data=f"lyrics_{i}")
            ])
        
        keyboard.append([InlineKeyboardButton("üéØ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏", callback_data="recommend")])
        
        await message.reply_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        await loading_msg.delete()
        await message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –∞—Ä—Ç–∏—Å—Ç–∞: {str(e)}")

async def handle_lyrics_search(message, query):
    loading_msg = await message.reply_text(
        f"üìú <b>–ò—â—É —Ç–µ–∫—Å—Ç –ø–µ—Å–Ω–∏:</b> <i>{query}</i>\n‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ...",
        parse_mode=ParseMode.HTML
    )
    
    try:
        lyrics = get_lyrics(query)
        await loading_msg.delete()
        
        if lyrics:
            if len(lyrics) > 4000:
                parts = [lyrics[i:i+4000] for i in range(0, len(lyrics), 4000)]
                for i, part in enumerate(parts):
                    header = f"üìú <b>–¢–µ–∫—Å—Ç –ø–µ—Å–Ω–∏</b> (—á–∞—Å—Ç—å {i+1}/{len(parts)}):\n\n" if i == 0 else ""
                    await message.reply_text(f"{header}<pre>{part}</pre>", parse_mode=ParseMode.HTML)
            else:
                await message.reply_text(f"üìú <b>–¢–µ–∫—Å—Ç –ø–µ—Å–Ω–∏:</b>\n\n<pre>{lyrics}</pre>", parse_mode=ParseMode.HTML)
        else:
            await message.reply_text(
                f"‚ùå <b>–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç–µ–∫—Å—Ç –¥–ª—è:</b> <i>{query}</i>\n\n"
                "‚ö†Ô∏è –°–µ—Ä–≤–∏—Å —Ç–µ–∫—Å—Ç–æ–≤ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –∏–∑-–∑–∞ —Ä–µ–≥–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π",
                parse_mode=ParseMode.HTML
            )
    except Exception as e:
        await loading_msg.delete()
        await message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞: {str(e)}")

async def handle_download(query, user_id):
    try:
        index = int(query.data.split("_")[1])
        
        if user_id not in user_search_results or index >= len(user_search_results[user_id]):
            await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –ø–µ—Å–Ω—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return
        
        selected_song = user_search_results[user_id][index]
        save_user_search(user_id, "download", selected_song)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —ç—Ç–æ –¥–µ–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç?
        if selected_song.get('source') == 'demo':
            await query.message.reply_text(
                f"‚ö†Ô∏è <b>–î–µ–º–æ —Ä–µ–∂–∏–º</b>\n\n"
                f"–≠—Ç–æ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è: <i>{selected_song['title']}</i>\n\n"
                "–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –∏–∑-–∑–∞ —Ä–µ–≥–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π YouTube.\n\n"
                "üí° –ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n"
                "‚Ä¢ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å VPN\n"
                "‚Ä¢ –î—Ä—É–≥–∏–µ –º—É–∑—ã–∫–∞–ª—å–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã\n"
                "‚Ä¢ –õ–æ–∫–∞–ª—å–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –º—É–∑—ã–∫–∏",
                parse_mode=ParseMode.HTML
            )
            return
        
        loading_msg = await query.message.reply_text(
            f"üì• <b>–°–∫–∞—á–∏–≤–∞—é:</b> <i>{selected_song['title']}</i>\n‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ...",
            parse_mode=ParseMode.HTML
        )
        
        try:
            # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ —Ñ–∞–π–ª—ã
            cleanup_old_files()
            
            # –°–∫–∞—á–∏–≤–∞–µ–º –∞—É–¥–∏–æ
            audio_path = download_audio(selected_song['url'], selected_song['title'])
            
            if audio_path and os.path.exists(audio_path):
                try:
                    with open(audio_path, 'rb') as audio_file:
                        await query.message.reply_audio(
                            audio=audio_file,
                            title=selected_song['title'],
                            caption=f"üéµ <b>{selected_song['title']}</b>",
                            parse_mode=ParseMode.HTML
                        )
                    # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
                    os.remove(audio_path)
                    await loading_msg.delete()
                except Exception as e:
                    await loading_msg.edit_text(
                        f"‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ:</b> <i>{str(e)}</i>",
                        parse_mode=ParseMode.HTML
                    )
            else:
                await loading_msg.edit_text(
                    f"‚ùå <b>–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å:</b> <i>{selected_song['title']}</i>\n\n"
                    f"–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n"
                    f"‚Ä¢ –†–µ–≥–∏–æ–Ω–∞–ª—å–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è\n"
                    f"‚Ä¢ –í–∏–¥–µ–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ\n"
                    f"‚Ä¢ –ü—Ä–æ–±–ª–µ–º—ã —Å —Å–µ—Ç—å—é\n\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥—É—é –ø–µ—Å–Ω—é –∏–∑ —Å–ø–∏—Å–∫–∞.",
                    parse_mode=ParseMode.HTML
                )
        except Exception as e:
            await loading_msg.edit_text(
                f"‚ùå <b>–û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è:</b> <i>{str(e)}</i>",
                parse_mode=ParseMode.HTML
            )
            
    except Exception as e:
        await query.message.reply_text(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {str(e)}")

async def handle_lyrics_from_search(query, user_id):
    try:
        index = int(query.data.split("_")[1])
        
        if user_id not in user_search_results or index >= len(user_search_results[user_id]):
            await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –ø–µ—Å–Ω—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return
        
        selected_song = user_search_results[user_id][index]
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —ç—Ç–æ –¥–µ–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç?
        if selected_song.get('source') == 'demo':
            await query.message.reply_text(
                f"‚ö†Ô∏è <b>–î–µ–º–æ —Ä–µ–∂–∏–º</b>\n\n"
                f"–≠—Ç–æ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è: <i>{selected_song['title']}</i>\n\n"
                "–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–≤ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –∏–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π API.",
                parse_mode=ParseMode.HTML
            )
            return
        
        loading_msg = await query.message.reply_text(
            f"üìú <b>–ü–æ–ª—É—á–∞—é —Ç–µ–∫—Å—Ç:</b> <i>{selected_song['title']}</i>\n‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ...",
            parse_mode=ParseMode.HTML
        )
        
        try:
            lyrics = get_lyrics(selected_song['title'])
            await loading_msg.delete()
            
            if lyrics:
                if len(lyrics) > 4000:
                    parts = [lyrics[i:i+4000] for i in range(0, len(lyrics), 4000)]
                    for i, part in enumerate(parts):
                        header = f"üìú <b>{selected_song['title']}</b> (—á–∞—Å—Ç—å {i+1}/{len(parts)}):\n\n" if i == 0 else ""
                        await query.message.reply_text(f"{header}<pre>{part}</pre>", parse_mode=ParseMode.HTML)
                else:
                    await query.message.reply_text(
                        f"üìú <b>{selected_song['title']}</b>\n\n<pre>{lyrics}</pre>",
                        parse_mode=ParseMode.HTML
                    )
            else:
                await query.message.reply_text(
                    f"‚ùå <b>–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç–µ–∫—Å—Ç –¥–ª—è:</b> <i>{selected_song['title']}</i>\n\n"
                    "‚ö†Ô∏è –°–µ—Ä–≤–∏—Å —Ç–µ–∫—Å—Ç–æ–≤ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω",
                    parse_mode=ParseMode.HTML
                )
        except Exception as e:
            await loading_msg.delete()
            await query.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞: {str(e)}")
            
    except Exception as e:
        await query.message.reply_text(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {str(e)}")

# Webhook –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
async def webhook_handler(request):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ webhook –æ—Ç Telegram"""
    try:
        data = await request.json()
        update = Update.de_json(data, app.bot)
        await app.process_update(update)
        return web.Response(status=200)
    except Exception as e:
        logger.error(f"Webhook error: {e}")
        return web.Response(status=500)

async def health_check(request):
    """Health check –¥–ª—è Render"""
    return web.Response(text="üéµ Music Bot is running! ‚úÖ", status=200)

async def setup_webhook():
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ webhook"""
    webhook_url = f"https://supermusicbot.onrender.com/webhook"
    await app.bot.set_webhook(webhook_url)
    logger.info(f"Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {webhook_url}")

def create_app():
    """–°–æ–∑–¥–∞–Ω–∏–µ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    web_app = web.Application()
    web_app.router.add_post('/webhook', webhook_handler)
    web_app.router.add_get('/', health_check)
    web_app.router.add_get('/health', health_check)
    return web_app

async def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    global app
    
    # –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –¥–ª—è –∑–∞–≥—Ä—É–∑–æ–∫
    os.makedirs("downloads", exist_ok=True)
    
    # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –±–æ—Ç–∞
    app = ApplicationBuilder().token(BOT_TOKEN).build()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
    app.add_error_handler(error_handler)

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(button_handler))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, text_handler))

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–æ—Ç–∞
    await app.initialize()
    await app.start()
    
    # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º webhook
    await setup_webhook()
    
    # –°–æ–∑–¥–∞–µ–º –≤–µ–±-—Å–µ—Ä–≤–µ—Ä
    web_app = create_app()
    
    port = int(os.environ.get('PORT', 10000))
    runner = web.AppRunner(web_app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', port)
    await site.start()
    
    logger.info("üéµ Music Bot –∑–∞–ø—É—â–µ–Ω –≤ WEBHOOK —Ä–µ–∂–∏–º–µ!")
    logger.info("‚ú® –§—É–Ω–∫—Ü–∏–∏:")
    logger.info("   ‚Ä¢ –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –≤—ã–±–æ—Ä –∏–∑ 5+ –ø–µ—Å–µ–Ω")
    logger.info("   ‚Ä¢ –ü–æ–∏—Å–∫ –ø–æ –∞—Ä—Ç–∏—Å—Ç—É")
    logger.info("   ‚Ä¢ –£–ª—É—á—à–µ–Ω–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏")
    logger.info("   ‚Ä¢ –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã –ø–æ–∏—Å–∫–∞")
    logger.info(f"   ‚Ä¢ Webhook —Å–µ—Ä–≤–µ—Ä –Ω–∞ –ø–æ—Ä—Ç—É {port}")
    
    # –î–µ—Ä–∂–∏–º —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω–Ω—ã–º
    while True:
        await asyncio.sleep(3600)

if __name__ == "__main__":
    asyncio.run(main())
